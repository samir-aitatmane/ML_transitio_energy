"""
üè° Application Streamlit : Simulation r√©novation √©nerg√©tique
------------------------------------------------------------
Cet outil permet :
1. De saisir les caract√©ristiques d‚Äôun logement et des travaux pr√©vus.
2. De calculer le co√ªt estim√© des travaux de r√©novation.
3. D‚Äôestimer le gain √©nerg√©tique potentiel via un mod√®le ML (fichier pickle).
4. De comparer co√ªts et gains pour diff√©rents travaux et combinaisons.

Structure du code :
- SECTION 1 : Importations et style
- SECTION 2 : Interface utilisateur (param√®tres logement, chauffage, isolation)
- SECTION 3 : Fonctions utilitaires (mappings, conversions)
- SECTION 4 : Fonction de calcul des co√ªts
- SECTION 5 : Pr√©diction du gain
- SECTION 6 : Calcul des co√ªts/gains pour combinaisons
- SECTION 7 : Tests

D√©pendances :
  execut√© cette commande dans le terminal :
   pip install -r requirements.txt
"""

# === SECTION 1 : IMPORTATIONS ===
import streamlit as st
import numpy as np
import pickle
import itertools
import matplotlib.pyplot as plt
import pandas as pd

# === MISE EN PAGE ET STYLING ===
st.markdown(
    """
    <style>
    .stApp {background: linear-gradient(120deg, #e0eafc 0%, #cfdef3 100%);}
    .big-font {font-size:22px !important; color:#1a237e;}
    .section-title {font-size:18px !important; color:#1565c0; margin-top: 30px;}
    </style>
    """,
    unsafe_allow_html=True
)

# === TITRE PRINCIPAL ===
st.markdown('<div class="big-font">üè° Simulation r√©novation √©nerg√©tique</div>', unsafe_allow_html=True)


# === SECTION 2 : INTERFACE UTILISATEUR ===
st.markdown('<div class="section-title">Param√®tres du logement</div>', unsafe_allow_html=True)

# --- Colonne gauche : infos g√©n√©rales ---
col1, col2 = st.columns(2)
with col1:
    surface = st.number_input("Surface habitable (m¬≤)", min_value=10, max_value=500, value=70)
    annee = st.number_input("Ann√©e de construction", min_value=1900, max_value=2025, value=1990)
    dpe = st.selectbox("DPE", ["Pas de DPE", "A", "B", "C", "D", "E", "F", "G"])
    region = st.selectbox(
        "R√©gion",
        [
            "√éle-de-France", "Hauts-de-France", "Grand Est", "Normandie", "Bretagne",
            "Pays de la Loire", "Centre-Val de Loire", "Bourgogne-Franche-Comt√©",
            "Auvergne-Rh√¥ne-Alpes", "Nouvelle-Aquitaine", "Occitanie", "PACA et Corse"
        ]
    )

# --- Colonne droite : √©quipements existants ---
with col2:
    travaux = st.multiselect(
        "Travaux effectu√©s",
        [
            "Isolation combles", "Isolation ext√©rieure", "Isolation plancher",
            "Chauffage", "Ventilation", "Eau chaude", "Ouvertures",
            "R√©gulation chauffage", "Toiture", "R√©novation sans isolation toiture",
            "Isolation int√©rieure"
        ]
    )
    chauffage_actuel = st.selectbox(
        "Type de chauffage actuel", ["Gaz", "Fioul", "√âlectrique", "Bois", "Mixte", "Autre"]
    )
    age_chauffage = st.selectbox(
        "√Çge du chauffage actuel", ["<10 ans", "10‚Äì15 ans", "15‚Äì20 ans", ">20 ans", "R√©nov√©", "Inconnu"]
    )
    ventilation = st.selectbox("Syst√®me de ventilation pr√©vu", ["Aucune", "Simple flux"])
    ecs_type = st.selectbox(
        "Type d'ECS (Eau Chaude Sanitaire)",
        ["Ballon ECS vertical", "Chauffe-eau thermodynamique", "Aucun"]
    )

# --- Chauffage apr√®s r√©novation ---
spec0_chauffage_label = st.selectbox(
    "Nouveau syst√®me de chauffage",
    ["Pas de changement", "Chaudi√®re condensation", "PAC", "Radiateurs √©lectriques"]
)
spec0_mapping = {
    "Pas de changement": -999,
    "Chaudi√®re condensation": 1,
    "PAC": 2,
    "Radiateurs √©lectriques": 3
}
spec0_chauffage = spec0_mapping[spec0_chauffage_label]

spec3_chauffage_label = st.selectbox(
    "Syst√®me install√© apr√®s r√©novation",
    ["Aucun", "PAC air/eau", "PAC air/air", "Chaudi√®re condensation", "Radiateurs √©lectriques"]
)
spec3_mapping = {
    "Aucun": -999,
    "PAC air/eau": 22,
    "PAC air/air": 21,
    "Chaudi√®re condensation": 12,
    "Radiateurs √©lectriques": 3
}
spec3_chauffage = spec3_mapping[spec3_chauffage_label]

# === SECTION : ISOLATION ===
st.markdown('<div class="section-title">Isolation</div>', unsafe_allow_html=True)

# --- Entr√©es isolation (colonne gauche) ---
col3, col4 = st.columns(2)
with col3:
    iti_type = st.selectbox("Type d‚Äôisolant ITI", ["Non renseign√©", "Laine de verre", "Isolant biosourc√©", "Isolant synth√©tique", "Isolant mince"])
    iti_surface = st.selectbox("Part de murs isol√©s (ITI)", ["0‚Äì25 %", "25‚Äì50 %", "50‚Äì100 %"])
    iti_epaisseur = st.slider("√âpaisseur ITI (cm)", min_value=0, max_value=50, value=20)
    iti_surface_m2 = st.number_input("Surface de mur √† isoler ITI (m¬≤)", min_value=0, max_value=500, value=0)
    toiture_type = st.selectbox("Type d‚Äôisolant toiture", ["Non renseign√©", "Laine de verre", "Isolant biosourc√©", "Isolant synth√©tique", "Isolant mince"])
    toiture_surface = st.selectbox("Part de surface isol√©e toiture", ["0‚Äì25 %", "25‚Äì50 %", "50‚Äì100 %"])
    toiture_epaisseur = st.slider("√âpaisseur toiture (cm)", min_value=0, max_value=50, value=20)
    toiture_surface_m2 = st.number_input("Surface de toiture √† isoler (m¬≤)", min_value=0, max_value=500, value=0)

# --- Entr√©es isolation (colonne droite) ---
with col4:
    plancher_type = st.selectbox("Type d‚Äôisolant plancher", ["Non renseign√©", "Laine de verre", "Isolant biosourc√©", "Isolant synth√©tique", "Isolant mince"])
    plancher_surface = st.selectbox("Part de surface isol√©e plancher", ["0‚Äì25 %", "25‚Äì50 %", "50‚Äì100 %"])
    plancher_epaisseur = st.slider("√âpaisseur plancher (cm)", min_value=0, max_value=50, value=20)
    plancher_surface_m2 = st.number_input("Surface de plancher √† isoler (m¬≤)", min_value=0, max_value=500, value=0)
    ite_type = st.selectbox("Type d‚Äôisolant ext√©rieur", ["Non renseign√©", "Laine de verre", "Isolant biosourc√©", "Isolant synth√©tique", "Isolant mince"])
    ite_surface = st.selectbox("Part de surface isol√©e ext√©rieure", ["0‚Äì25 %", "25‚Äì50 %", "50‚Äì100 %"])
    ite_epaisseur = st.slider("√âpaisseur ITE (cm)", min_value=0, max_value=50, value=20)
    ite_surface_m2 = st.number_input("Surface de mur √† isoler ITE (m¬≤)", min_value=0, max_value=500, value=0)
    ouvertures_ratio = st.selectbox("Proportion des ouvertures r√©nov√©es", ["Aucune", "0‚Äì25%", "25‚Äì50%", "50‚Äì75%", "75‚Äì100%"])


# === SECTION 3 : FONCTIONS UTILITAIRES ===
def annee_to_anciennete(annee):
    """
    Convertit l'ann√©e de construction en code d'anciennet√©.
    Codes :
        1 = avant 1948
        2 = 1948-1974
        3 = 1975-1981
        4 = 1982-1989
        5 = 1990-2000
        6 = 2001-2012
        7 = apr√®s 2012
    """
    if annee < 1948: return 1
    elif annee <= 1974: return 2
    elif annee <= 1981: return 3
    elif annee <= 1989: return 4
    elif annee <= 2000: return 5
    elif annee <= 2012: return 6
    else: return 7

# === SECTION 3  : FONCTIONS UTILITAIRES ===

def dpe_to_code(dpe):
    """
    Convertit la lettre DPE en code num√©rique pour le mod√®le.

    Param√®tres :
        dpe (str) : Lettre de DPE ("A", "B", ..., "G" ou "Pas de DPE")

    Retour :
        int : Code DPE (A=1, ..., G=7, Pas de DPE=-999)
    """
    mapping = {
        "A": 1, "B": 2, "C": 3, "D": 4,
        "E": 5, "F": 6, "G": 7, "Pas de DPE": -999
    }
    return mapping.get(dpe, -999)


def region_to_code(region):
    """
    Attribue un code num√©rique √† chaque r√©gion.

    Param√®tres :
        region (str) : Nom complet de la r√©gion.

    Retour :
        int : Code num√©rique (1 √† 12)
    """
    mapping = {
        "√éle-de-France": 1, "Hauts-de-France": 2, "Grand Est": 3,
        "Normandie": 4, "Bretagne": 5, "Pays de la Loire": 6,
        "Centre-Val de Loire": 7, "Bourgogne-Franche-Comt√©": 8,
        "Auvergne-Rh√¥ne-Alpes": 9, "Nouvelle-Aquitaine": 10,
        "Occitanie": 11, "PACA et Corse": 12
    }
    return mapping.get(region, -999)


def surface_to_code(surface_str):
    """
    Convertit la proportion d‚Äôisolation en code.

    Param√®tres :
        surface_str (str) : Texte tel que "0‚Äì25 %", "25‚Äì50 %", "50‚Äì100 %".

    Retour :
        int : Code (1=0‚Äì25%, 2=25‚Äì50%, 3=50‚Äì100%)
    """
    mapping = {"0‚Äì25 %": 1, "25‚Äì50 %": 2, "50‚Äì100 %": 3}
    return mapping.get(surface_str, 0)


def ouvertures_to_code(ratio):
    """
    Convertit la proportion d'ouvertures r√©nov√©es en code.

    Param√®tres :
        ratio (str) : Proportion textuelle.

    Retour :
        int : Code (0 √† 4)
    """
    mapping = {
        "Aucune": 0, "0‚Äì25%": 1, "25‚Äì50%": 2,
        "50‚Äì75%": 3, "75‚Äì100%": 4
    }
    return mapping.get(ratio, 0)


def isolant_to_code(type_isolant):
    """
    Associe un code num√©rique √† un type d‚Äôisolant.

    Param√®tres :
        type_isolant (str) : Nom de l‚Äôisolant.

    Retour :
        int : Code (0=non renseign√©, 1 √† 4 selon le type)
    """
    mapping = {
        "Non renseign√©": 0, "Laine de verre": 1,
        "Isolant biosourc√©": 2, "Isolant synth√©tique": 3,
        "Isolant mince": 4
    }
    return mapping.get(type_isolant, 0)


# === SECTION 4 : CALCUL DU CO√õT TOTAL ===

def calcul_cout_total_intelligent(travaux, surfaces, epaisseurs):
    """
    Calcule le co√ªt total estim√© des travaux de r√©novation.

    Param√®tres :
        travaux (list[str]) :
            Liste des types de travaux √† r√©aliser
            (ex: "Isolation combles", "Chauffage", etc.)
        surfaces (dict) :
            Surfaces en m¬≤ associ√©es √† certains travaux
            (ex: {"Isolation combles": 50, "Isolation ext√©rieure": 80, ...})
        epaisseurs (dict) :
            √âpaisseurs d‚Äôisolants en cm pour certains travaux.

    Retour :
        float : Co√ªt total en euros (arrondi √† l‚Äôeuro pr√®s).
    """
    cout_total = 0

    # Prix unitaires moyens (‚Ç¨/m¬≤ ou forfait)
    prix_unitaires = {
        "Isolation combles": 40,
        "Isolation ext√©rieure": 120,
        "Isolation plancher": 80,
        "Chauffage": 8000,
        "Ventilation": 3500,
        "Eau chaude": 2000,
        "Ouvertures": 500,
        "R√©gulation chauffage": 1500,
        "Toiture": 10000,
        "Isolation int√©rieure": 60
    }

    for t in travaux:
        if t in surfaces:
            cout_total += prix_unitaires.get(t, 0) * surfaces[t]
        else:
            cout_total += prix_unitaires.get(t, 0)

    return round(cout_total, 2)


# === SECTION 5 : PR√âDICTION DU GAIN √âNERG√âTIQUE ===

def prediction_gain(features, model_path="modele_ml.pkl"):
    """
    Utilise un mod√®le Machine Learning pr√©-entrain√© pour estimer
    le gain √©nerg√©tique apr√®s travaux.

    Param√®tres :
        features (list[float]) :
            Liste des caract√©ristiques num√©riques d'entr√©e pour le mod√®le.
        model_path (str) :
            Chemin du fichier pickle contenant le mod√®le entra√Æn√©.

    Retour :
        float : Gain √©nerg√©tique estim√© (en %).
    """
    try:
        with open(model_path, "rb") as f:
            model = pickle.load(f)
        gain = model.predict([features])[0]
        return float(gain)
    except FileNotFoundError:
        st.error("‚ö† Mod√®le ML introuvable.")
        return 0.0


# === SECTION 6 : CALCUL DES COMBINAISONS TRAVAUX ===

def calcul_comparatif(travaux_possibles, surfaces, epaisseurs):
    """
    Calcule et compare le co√ªt et le gain √©nerg√©tique
    pour toutes les combinaisons possibles de travaux.

    Param√®tres :
        travaux_possibles (list[str]) :
            Liste des types de travaux envisageables.
        surfaces (dict) :
            Surfaces associ√©es aux travaux.
        epaisseurs (dict) :
            √âpaisseurs associ√©es aux travaux.

    Retour :
        pd.DataFrame :
            Tableau avec colonnes ["Travaux", "Co√ªt (‚Ç¨)", "Gain (%)"]
    """
    combinaisons = []
    for r in range(1, len(travaux_possibles) + 1):
        for combo in itertools.combinations(travaux_possibles, r):
            cout = calcul_cout_total_intelligent(combo, surfaces, epaisseurs)
            features = [surface, annee_to_anciennete(annee), dpe_to_code(dpe), region_to_code(region)]
            gain = prediction_gain(features)
            combinaisons.append({"Travaux": ", ".join(combo), "Co√ªt (‚Ç¨)": cout, "Gain (%)": gain})

    return pd.DataFrame(combinaisons)


# === SECTION 7 : TESTS ===

if st.button("Calculer co√ªt et gain"):
    surfaces_dict = {
        "Isolation combles": toiture_surface_m2,
        "Isolation ext√©rieure": ite_surface_m2,
        "Isolation plancher": plancher_surface_m2,
        "Isolation int√©rieure": iti_surface_m2
    }
    epaisseurs_dict = {
        "Isolation combles": toiture_epaisseur,
        "Isolation ext√©rieure": ite_epaisseur,
        "Isolation plancher": plancher_epaisseur,
        "Isolation int√©rieure": iti_epaisseur
    }

    cout_total = calcul_cout_total_intelligent(travaux, surfaces_dict, epaisseurs_dict)
    st.success(f"üí∞ Co√ªt total estim√© : {cout_total:,.0f} ‚Ç¨")

    features = [surface, annee_to_anciennete(annee), dpe_to_code(dpe), region_to_code(region)]
    gain_estime = prediction_gain(features)
    st.info(f"üìà Gain √©nerg√©tique estim√© : {gain_estime:.2f} %")

    # Comparaison multi-travaux
    st.subheader("Comparaison des combinaisons de travaux")
    df = calcul_comparatif(
        ["Isolation combles", "Isolation ext√©rieure", "Chauffage"],
        surfaces_dict, epaisseurs_dict
    )
    st.dataframe(df)
